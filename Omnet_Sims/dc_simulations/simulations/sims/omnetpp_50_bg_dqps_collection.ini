[General]
cmdenv-express-mode = false
cmdenv-event-banners = true
cmdenv-status-frequency = 1000000000000s

network = LeafSpine

**.ipv4.ip.timeToLive = ${ttl = 250}
**.tcp.close_instead_of_timewait = ${closeInsteadOfWait = true}
**.tcp.FRs_disabled = ${FRsDisabled = false}
**.useECMP = ${usingECMP = true}
**.use_power_of_n_lb = ${usingPowerOfNLB = false}
**.agg[*].random_power_factor = ${aggRandomPowerFactor = 2}
**.spine[*].random_power_factor = ${spineRandomPowerFactor = $aggRandomPowerFactor}
**.tcp.tcpAlgorithmClass = "DCTcp"
**.tcp.ecnWillingness = ${ecnWill = true}

# Collection runs use 10/40Gbps traces, so the longer simulation horizon from the large-scale configs applies.
sim-time-limit = 1.2s

# Marking configuration derived from 10/40Gbps scenarios.
**.ipv4.ip.should_use_v2_marking = true
**.ipv4.ip.marking_type = ${markingType = "SRPT"}
**.ipv4.ip.delta = ${markingTimer = 0.00036}s
**.ipv4.ip.has_ordering_layer = ${hasOrderingLayer = false}
**.ipv4.ip.omega = ${orderingTimer = 0.00036}s

**.num_spines = ${numSpines = 4}
**.num_aggs = ${numAggs = 8}
**.num_servers = ${numServers = 40}
**.num_bursty_apps = ${numBurstyApps = 1}
**.server[*].app[1..].num_requests_per_burst = ${numReqPerBurst = 100}
**.num_mice_background_flow_apps_in_each_server = ${numMiceBackgroundFlowAppsInEachServer = 1}
**.num_elephant_background_flow_apps_in_each_server = ${numElephantBackgroundFlowAppsInEachServer = 0}

**.server[*].app[1..].startTime = 0s
**.server[*].app[1..].replyLength = ${incastFlowSize = 40000}B
**.server[*].app[1..].requestLength = 250B
**.server[*].app[1..].application_category = ${serverApplicationCategory = index() < 1 + $numMiceBackgroundFlowAppsInEachServer ? "cache" : "web"}
**.server[*].app[1..].background_inter_arrival_time_multiplier = ${bgInterArrivalMultiplier = 0.2428}
**.server[*].app[1..].background_flow_size_multiplier = ${bgFlowSizeMultiplier = 1}
**.server[*].app[1..].bursty_inter_arrival_time_multiplier = ${burstyInterArrivalMultiplier = 0.125, 0.0405, 0.0243, 0.0174, 0.0135}
**.server[*].app[1..].bursty_flow_size_multiplier = ${burstyFlowSizeMultiplier = 1}
**.server[*].app[1..].numRequestsToSend = 1
**.server[*].app[1..].distibutions_base_root = "./"

# Use Vertigo priority queues per UNIFORM_RANDOM baseline.
**.agg[*].eth[*].mac.queue.typename = "V2PIFOPrioQueue"
**.spine[*].eth[*].mac.queue.typename = "V2PIFOPrioQueue"
**.agg[*].eth[*].mac.queue.queue_num = 8
**.spine[*].eth[*].mac.queue.queue_num = 8
**.agg[*].eth[*].mac.queue.priority_mapping_scheme = "FIFO"
**.spine[*].eth[*].mac.queue.priority_mapping_scheme = "FIFO"

# Queue dropper/scheduler/DCTCP thresh (from DCTCP_SD)
**.agg[*].eth[*].mac.queue.dropper_type = ${aggDropperType = "FIFO"}
**.agg[*].eth[*].mac.queue.scheduler_type = ${aggSchedulerType = "FIFO"}
**.agg[*].eth[*].mac.queue.dctcp_thresh = ${aggQueueSizeDCTCPThresh = 20}
**.spine[*].eth[*].mac.queue.dropper_type = ${spineDropperType = $aggDropperType}
**.spine[*].eth[*].mac.queue.scheduler_type = ${spineSchedulerType = $aggSchedulerType}
**.spine[*].eth[*].mac.queue.dctcp_thresh = ${spineQueueSizeDCTCPThresh = $aggQueueSizeDCTCPThresh}

# Restore buffer capacity to 300,000B to match 10/40Gbps experiments.
**.agg[*].eth[*].mac.queue.dataCapacity = ${aggQueueSizePacketBytes = 300000}B
**.spine[*].eth[*].mac.queue.dataCapacity = ${spineQueueSizePacketBytes = $aggQueueSizePacketBytes}B

# Vertigo / PIFO switches
**.agg[*].use_vertigo_prio_queue = false
**.spine[*].use_vertigo_prio_queue = false
**.agg[*].use_v2_pifo = true
**.spine[*].use_v2_pifo = true

# MAC / relay types (from DCTCP_SD)
**.agg[*].eth[*].mac.typename = ${aggMacTypeName = "AugmentedEtherMac"}
**.spine[*].eth[*].mac.typename = ${spineMacTypeName = $aggMacTypeName}
**.agg[*].relayUnit.typename = ${aggRelayTypeName = "BouncingIeee8021dRelay"}
**.spine[*].relayUnit.typename = ${spineRelayTypeName = $aggRelayTypeName}

# Ensure flow/requester vectors are recorded for this config.
**.server[*].app[*].requestSentRequesterID.statistic-recording = true
**.server[*].app[*].flowStartedRequesterID.statistic-recording = true
**.server[*].app[*].flowEndedRequesterID.statistic-recording = true
**.server[*].app[*].replyLengthAsked.statistic-recording = true
**.agg[*].relayUnit.requesterID.statistic-recording = true
**.agg[*].relayUnit.switchId.statistic-recording = true
**.agg[*].relayUnit.FlowID.statistic-recording = true
**.agg[*].relayUnit.PacketSize.statistic-recording = true
**.agg[*].relayUnit.PacketAction.statistic-recording = true
**.spine[*].relayUnit.requesterID.statistic-recording = true
**.spine[*].relayUnit.switchId.statistic-recording = true
**.spine[*].relayUnit.FlowID.statistic-recording = true
**.spine[*].relayUnit.PacketSize.statistic-recording = true
**.spine[*].relayUnit.PacketAction.statistic-recording = true

# ARP / MAC learning / tables (from DCTCP_SD)
**.arp.typename = "GlobalArp"
**.agg[*].learn_mac_addresses = false
**.spine[*].learn_mac_addresses = false
**.agg[*].macTable.addressTableFile ="./MAC_Table_Data/agg[" + string(parentIndex()) + "].txt"
**.spine[*].macTable.addressTableFile ="./MAC_Table_Data/spine[" + string(parentIndex()) + "].txt"

# APP
**.server[*].numApps = ${server0NumApps = 1 + $numMiceBackgroundFlowAppsInEachServer + $numBurstyApps}
**.server[*].app[1..].is_bursty = ${server0IsBursty = index() < 1 + $numMiceBackgroundFlowAppsInEachServer ? false : true}
**.server[*].app[0].typename = "DCTcpGenericServerApp"
**.server[*].app[0].localPort = 80
**.server[*].app[1..].typename = "MultiSocketBasicClient"
**.server[*].app[1..].is_mice_background = ${serverIsMiceBackground = index() < 1 + $numMiceBackgroundFlowAppsInEachServer ? true : false}


[Config UNIFORM_RANDOM]
extends = General

# Override queue implementation to single-queue V2PIFO for uniform-random deflection
**.agg[*].eth[*].mac.queue.typename = "V2PIFO"
**.spine[*].eth[*].mac.queue.typename = "V2PIFO"
**.agg[*].use_vertigo_prio_queue = false
**.spine[*].use_vertigo_prio_queue = false
**.agg[*].use_v2_pifo = true
**.spine[*].use_v2_pifo = true
**.agg[*].relayUnit.use_vertigo_prio_queue = false
**.spine[*].relayUnit.use_vertigo_prio_queue = false
**.agg[*].relayUnit.use_v2_pifo = true
**.spine[*].relayUnit.use_v2_pifo = true
# Deflection / bouncing flags: prefer UNIFORM_RANDOM values (disable legacy ones, enable uniform random)
# **.agg[*].bounce_randomly = false
**.agg[*].bounce_randomly_v2 = false
**.agg[*].bounce_probabilistically = false
**.agg[*].bounce_with_rl_policy = false
**.agg[*].bounce_naively = false

**.spine[*].bounce_randomly = false
**.spine[*].bounce_randomly_v2 = false
**.spine[*].bounce_probabilistically = false
**.spine[*].bounce_with_rl_policy = false
**.spine[*].bounce_naively = false

**.agg[*].bounce_randomly_v2 = ${aggBounceRandomlyPowerOfN = false}
**.spine[*].bounce_randomly_v2 = ${spineBounceRandomlyPowerOfN = $aggBounceRandomlyPowerOfN}
**.agg[*].random_power_bounce_factor = ${aggBounceRandomlyPowerFactor = 2}
**.spine[*].random_power_bounce_factor = ${spineBounceRandomlyPowerFactor = $aggBounceRandomlyPowerFactor}

# Keep other deflection-related params from DCTCP_SD
# Ensure legacy bounce_randomly is disabled for UNIFORM_RANDOM experiments
**.agg[*].bounce_randomly = ${aggBounceRandomly = false}
**.agg[*].filter_out_full_ports = ${aggFilterOutFullPorts = true}
**.agg[*].approximate_random_deflection = ${aggApproximateRandomDeflection = true}
**.spine[*].bounce_randomly = ${spineBounceRandomly = $aggBounceRandomly}
**.spine[*].filter_out_full_ports = ${spineFilterOutFullPorts = $aggFilterOutFullPorts}
**.spine[*].approximate_random_deflection = ${spineApproximateRandomDeflection = $aggApproximateRandomDeflection}

**.agg[*].denominator_for_retrasnmissions = ${aggDenomRet = 2}
**.spine[*].denominator_for_retrasnmissions = ${spineDenomRet = $aggDenomRet}

# UNIFORM_RANDOM: enable uniform-random mode and per-switch RNG seed
# Also enable one of the legacy bounce flags so `can_deflect` becomes true
# (avoids modifying C++ initialization). We'll use bounce_randomly which
# is already referenced by the can_deflect initializer.
**.agg[*].bounce_uniform_random = true
**.spine[*].bounce_uniform_random = true
**.agg[*].bounce_randomly = true
**.spine[*].bounce_randomly = true
**.agg[*].relayUnit.uniform_random_seed_base = 1000
**.spine[*].relayUnit.uniform_random_seed_base = 1000
**.agg[*].relayUnit.uniform_random_deflect_prob = ${eps = 0.05, 0.1, 0.2}
**.spine[*].relayUnit.uniform_random_deflect_prob = ${eps}

# Also set the relayUnit-scoped parameters explicitly to avoid ancestor-scope ambiguity
**.agg[*].relayUnit.bounce_uniform_random = true
**.spine[*].relayUnit.bounce_uniform_random = true
**.agg[*].relayUnit.bounce_randomly = true
**.spine[*].relayUnit.bounce_randomly = true

# Output files: prefer UNIFORM_RANDOM filenames for the main outputs (keep original eventlog/snapshot if needed)

# Shortened output filenames to avoid filesystem filename-length limits
cmdenv-output-file = results/uniform_random/uni_random_eps_${eps}_rep_${repetition}.out

output-scalar-file = results/uniform_random/uni_random_eps_${eps}_rep_${repetition}.sca

output-vector-file = results/uniform_random/uni_random_eps_${eps}_rep_${repetition}.vec

# Shortened eventlog/snapshot names for UNIFORM_RANDOM runs
eventlog-file = results/uni_random_eps_${eps}_rep_${repetition}.elog
snapshot-file = results/uni_random_eps_${eps}_rep_${repetition}.sna

[Config PROBABILISTIC]
extends = General

# Define sweep variables used by PROBABILISTIC so opp_runall can expand runs.
# These provide default single values; change to comma-separated lists to sweep.
**.agg[*].relayUnit.deflect_prob_theta = ${theta = 0.7}
**.agg[*].relayUnit.deflect_prob_beta = ${beta = 0.05}
**.agg[*].relayUnit.uniform_random_deflect_prob = ${eps = 0.05}

# Output names mirror the UNIFORM_RANDOM ones for convenience.
cmdenv-output-file = results/probabilistic/prob_eps_${eps}_theta_${theta}_beta_${beta}_rep_${repetition}.out
output-scalar-file = results/probabilistic/prob_eps_${eps}_theta_${theta}_beta_${beta}_rep_${repetition}.sca
output-vector-file = results/probabilistic/prob_eps_${eps}_theta_${theta}_beta_${beta}_rep_${repetition}.vec
